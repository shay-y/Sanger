---
title: "Sanger Rare Event Data Analysis."
author: "S.Y"
date: "Tuesday, January 12, 2015"
output: pdf_document
---

**Notes:**

* single pipeline for a common genetic background core strain equally B6N. 
* In the datasets are a number of knockout animals and a large number of controls.  
* group of knockout animals and compare to the control data (genotype=+/+).
* There are 473 different datasets for comparison with 46 variables of interest.  

* Proportions of subjects (mices) with defected outcome in the group are compared between the KO and WT groups for each KO and each outcome. Tested with Exact Fisher test.
* Multiplicity correction to control FDR is applied for each outcome with 4 procedures:
    * BH
    * BH on family of tests (KO's) where minimum attainble p-value smaller than $0.05$
    * BH on Tarone family - minimum attainble p-value smaller than $0.05/K$. $K$ corresponds number of hypotheses that can be tested after bonferroni correction.
    * BH on family chosen according to first maximal $m_1$ estimate: we estimate $m_1$ for sub-families, where each family is chosen such that $\alpha^*_i < t$. for various thresholds $t$ defined by the quantiles of $\alpha^*$.  Then the smallest sub-family with the maximal $m_1$ estimate is chosen.
    
**results:** the later procedures discovers more KO groups with higher proportion of defected outcomes.
    
## Code , detailed results and plots:
    
```{r}
rm(list = ls())
## read index file:
# index <- read.csv(file = "Index.csv")
# apply(index,2,function(x) length(unique(x)))            # no unique key
# sum(duplicated(index[c(2,5)]))                          # Colony.Prefix & Genotype2 construct unique key
# sum(index[,2] %in% index[duplicated(index[,2]),2])      # there are 24 pairs of HOM & HET in the same genotype

## read 0\1 data:
zoo <- read.csv(file = "Oct29_2014_Xray_B6N_MGPSelect_Oor1_cleanedSY.csv") # 8176,79 

## 46 variables of interest:
XrayVariableList <- c("Number.Of.Thoracic.Vertebrae","Number.Of.Lumbar.Vertebrae","Number.Of.Pelvic.Vertebrae","Number.Of.Caudal.Vertebrae", "Transitional.Vertebrae" , "Shape.Of.Vertebrae","Fusion.Of.Vertebrae", "Processes.On.Vertebrae","Maxilla","Zygomatic.Bone","Number.Of.Cervical.Vertebrae","Skull.Shape","Number.Of.Ribs.Right","Number.Of.Ribs.Left","Shape.Of.Ribcage","Shape.Of.Ribs","Rib.Fusions","Clavicle","Scapula"  ,"Humerus","Radius","Ulna","Pelvis","Femur","Tibia","Fibula","Joints","Shape.Of.Spine","Teeth","Mandible","Number.Of.Digits","Digit.Integrity","Syndactylism","Polysyndactylism","Brachydactylism","Kyphosis","Lordosis","Scoliosis","Spinous.Processes","Transverse.Processes","Fusion.Processes","Caudal.Processes","Cervical.Processes","Lumbar.Processes","Sacral.Processes","Thoracic.Processes")    

## remove 3 variables with no values:
XrayVariableList_c <- XrayVariableList[!(XrayVariableList %in% c("Spinous.Processes","Transverse.Processes","Processes.On.Vertebrae"))]

## remove 3 cases with all NA's and leave in variables of interest only:
zoo1 <- zoo[-which(apply(zoo[XrayVariableList_c],1,function(x) all(is.na(x))))
,c("Colony.Prefix","Genotype2","Genotype",XrayVariableList_c)]

# count the number of mices in each KO group (except WT group)
n_t     <- aggregate(. ~ Genotype2 + Colony.Prefix, data = zoo1, subset = Genotype2 !="WT",
                     function(x) sum(!is.na(x)),na.action=NULL)

# count the number NAs in each KO group (except WT group)
n_na_KO <- aggregate(. ~ Genotype2 + Colony.Prefix, data = zoo1, subset = Genotype2 !="WT",
                     function(x) sum(is.na(x)),na.action=NULL)

# count the number of mices-marked-with-one in each KO group (except WT group)
n <- aggregate(. ~ Genotype2 + Colony.Prefix,data = zoo1,subset = Genotype2 !="WT",
               sum, na.action=NULL, na.rm=T)

# count the number of mices in the WT group
N_minus_n_t <- aggregate(. ~ Genotype2 ,data = zoo1,subset = Genotype2 =="WT",
                         function(x) sum(!is.na(x)),na.action=NULL)

# count the number NAs in the WT group
n_na_WT <- aggregate(. ~ Genotype2 ,data = zoo1,subset = Genotype2 =="WT",
                         function(x) sum(is.na(x)),na.action=NULL)

# count the number of mices-marked-with-one in the WT
n_u_minus_n <- aggregate(. ~ Genotype2 ,data = zoo1,subset = Genotype2 =="WT",
                         sum, na.action=NULL, na.rm=T)

### Objects dimentions for all 43 outcomes:

## n           : 473 X 46 - number of faulted mice in each of the 473 KO in each outcome 
## n_t         : 473 X 46 - number of tested  mice in each of the 473 KO in each outcome 
## n_u_minus_n : 1 X 46   - number of faulted WT in each outcome 
## N_minus_n_t : 1 X 46   - number of tested  WT in each outcome (= 1853)

### For one outcome (column i)

## n[,i]           : 473 values - number of faulted mice in each of the 473 KO((x = #white balls drawn))
## n_t[,i]         : 473 values - number of tested  mice in each of the 473 KO((k = #balls drawn))
## n_u_minus_n[,i] : one value  - number of faulted WT 
## N_minus_n_t[,i] : one value  - number of tested  WT = 1853

## n_u - faulted mice in total ((m = white balls))
## B   - last value in the support of HG, is min{n_t,n_u} - the minimum between total faults and tested mice in KO group

## print table of outcome i and KO j:
ptable <- function(j,i)
{
  n_u1 <- n_u_minus_n[,i]+n[j,i]
  N1 <- N_minus_n_t[,i] + n_t[j,i]
  n_t1 <- n_t[j,i]
  n1  <- pmin(n[j,i],n_t1,n_u1)
  tb <- matrix(c(n1     ,n_u1-n1       ,  n_u1,
               n_t1-n1,N1-n_t1-n_u1+n1,N1-n_u1,
               n_t1   ,N1-n_t1        ,N1),
               nrow=3,ncol=3,byrow=T)
  dimnames(tb) <- list("Defected"=c("Y","N","TOTAL"),
                       "Group"=c("KO","WT","TOTAL"))
  tbna <- matrix(c(n_na_KO[j,i],n_na_WT[,i],n_na_KO[j,i]+n_na_WT[,i]),nrow=1,ncol=3,byrow=T)
  dimnames(tbna) <- list("#NAs","Group"=c("KO","WT","TOTAL"))
  print(tb)
  print(tbna)
}

ptable(4,4)
ptable(8,8)
ptable(10,10)
```

```{r}
## function to calculate the size of the Tarone family:
findK <- function(alpha_star,alpha=0.05,range = NULL,verbose=T)
  # finds K(alpha)=inf{1:j|m(alpha,j)<=j} where m(alpha,j)=#{i|alpha_star[i]<=alpha/j}
{
  la <- length(alpha_star) 
  if (is.null(range))
    range <- 1:la
  m <- vector(length=la)
  for (j in range)
  {
    m[j] <- sum(alpha_star<=(alpha/j))
    #cat("j: ",j," m[j]:",m[j],"\n")
  }
  K <- (1:la)[which(m<=(1:la))[1]]
  if (verbose) cat("K = ",K,"\n")
  return (K)
}

lambda <- 0.05

alpha_star<-p<-p_rand<-pa_BH<-pa_BH_0.05<-pa_Gilb<-pa_new<-m1_hat<- matrix(NA,nrow = nrow(n), ncol = ncol(n))
size_F_0.05 <- K <- argmax_m1_hat<-  rep(NA,ncol(n))

for (i in 4:46)
{i=4
  # work with phyper() notation:
  mm <- n_u_minus_n[,i]+n[,i]
  nn <- N_minus_n_t[,i] + n_t[,i] - mm
  kk  <- n_t[,i]
  BB  <- pmin(mm,kk)
  stopifnot(n[,i]<=BB)
  xx  <- pmin(n[,i],BB)
  
  # get pv (right tail) and alpha star:
  p[,i]  <- dhyper(x = xx, m = mm, n = nn, k = kk) + phyper(q = xx, m = mm, n = nn, k = kk, lower.tail = FALSE)
  alpha_star[,i] <- dhyper(x=BB, m = mm, n = nn, k = kk)

  f_n <- dhyper(x = xx, m = mm, n = nn, k = kk)
  kappa <- apply(cbind(BB,mm,nn,kk,f_n),1,
               function(x) sum(dhyper(x = 0:x[1], m = x[2], n = x[3], k = x[4])==x[5]))

  # BH adjustment:
  pa_BH[,i] <- p.adjust(p[,i],"BH")
  
  # BH on minimum attainble pv smaller than sig. level 0.05:
  F_0.05 <- alpha_star[,i]<=0.05
  size_F_0.05[i] <- sum(F_0.05)
  pa_BH_0.05[,i] <- 1
  pa_BH_0.05[F_0.05,i] <- p.adjust(p[F_0.05,i],"BH")
  
  # BH on Tarone family:
  K[i] <- findK(alpha_star[,i])
  F_Gilb <- alpha_star[,i]<=0.05/K[i]
  pa_Gilb[,i] <- 1
  pa_Gilb[F_Gilb,i] <- p.adjust(p[F_Gilb,i],"BH")
  
  # estimation of m1 for each sub-family thresholded by alphastar
  t <- sort(alpha_star[,i])
  for (j in 1:length(t))
    {j=200
    in_fam <- alpha_star[,i] <= t[j]
    m_tag <- sum(in_fam)
    
    lpl <- (lambda < p[in_fam,i]) & (p[in_fam,i] <= lambda + kappa[in_fam]*f_n[in_fam])
    EU_ecdf_lambda <- (sum(p[in_fam,i]<=lambda))/m_tag + (sum(1 - (p[lpl,i]-lambda) / (kappa[lpl]*f_n[lpl]) ))/m_tag
           
    EU_Pi_0_hat <- (1-EU_ecdf_lambda)/(1-lambda)
    
    m1_hat[,i]  <- m_tag*(1-EU_Pi_0_hat)
    }
  # choice of optimum sub family:
  argmax_m1_hat[i] <- which.max(m1_hat[,i])
  
  F_new <- alpha_star[,i]<=t[argmax_m1_hat[i]]
  pa_new[,i] <- 1
  pa_new[F_new,i] <- p.adjust(p[F_new,i],"BH")
}
m1_hat


Rej <- data.frame(size_F_0.05,K,argmax_m1_hat,BH=apply(pa_BH,2,function(x) sum(x<=0.05)),BH0.05=apply(pa_BH_0.05,2,function(x) sum(x<=0.05)),Gilbert=apply(pa_Gilb,2,function(x) sum(x<=0.05)),m1est=apply(pa_new,2,function(x) sum(x<=0.05)))[-(1:3),]

Rejdiff <- data.frame("BH0.05--BH"=Rej[3+2]-Rej[3+1],"Gilb--BH"=Rej[3+3]-Rej[3+1],"m1est--BH"=Rej[3+4]-Rej[3+1])
rownames(Rej) <- XrayVariableList_c
rownames(Rejdiff) <- XrayVariableList_c

Rej
colSums(Rej)
Rejdiff
colSums(Rejdiff)  
```
```{r echo=FALSE}
#   # kk<=mm
#   mm <- 7
#   nn <- 10
#   kk <- 6
#   B <- min(kk,mm)
#   xx <- 4:B
#   
#   dhyper(x=xx, m = mm, n = nn, k = kk)
#   choose(mm,xx)*choose(nn,kk-xx)/choose(mm+nn,kk)
#   choose(mm,kk)/choose(mm+nn,kk)
#   
#   # kk>mm
#   mm <- 7
#   nn <- 10
#   kk <- 8
#   B <- min(kk,mm)
#   xx <- 4:B
#   
#   dhyper(x=xx, m = mm, n = nn, k = kk)
#   choose(mm,xx)*choose(nn,kk-xx)/choose(mm+nn,kk)
#   choose(nn,kk-mm)/choose(mm+nn,kk)

```

```{r,fig.height=16,fig.width=7,echo=FALSE}
#  plots:
par(mfrow=c(2,3))
for (i in 3+(1:43))
{
  plot(sort(p[,i]),type="l",main = "p-value")
  plot(sort(alpha_star[,i]),type="l",main = "alpha_star")
#   asf <- table(alpha_star[,i])
#   asv <- as.numeric(names(asf))
#   plot(asv,cumsum(asf),type="h",lwd=1,col="darkgrey",xlab="x",ylab="counts")
  plot(m1_hat[,i],type="l",main = "m1 hat ")
  abline(v=c(size_F_0.05[i],K[i],argmax_m1_hat[i]),col=c("brown","red","orange"))
}
```

