---
title: "Sanger Rare Event Data Analysis."
author: "S.Y"
date: "Tuesday, January 12, 2015"
output: pdf_document
---

**Notes:**

* single pipeline for a common genetic background core strain equally B6N. 
* In the datasets are a number of knockout animals and a large number of controls.  
* group of knockout animals and compare to the control data (genotype=+/+).
* There are 473 different datasets for comparison with 46 variables of interest.  

* Proportions of subjects (mices) with defected outcome in the group are compared between the KO and WT groups for each KO and each outcome. Tested with Exact Fisher test.
* Multiplicity correction to control FDR is applied for each outcome with 4 procedures:
    * BH
    * BH on family of tests (KO's) where minimum attainble p-value smaller than $0.05$
    * BH on Tarone family - minimum attainble p-value smaller than $0.05/K$. $K$ corresponds number of hypotheses that can be tested after bonferroni correction.
    * BH on family chosen according to first maximal $m_1$ estimate: we estimate $m_1$ for sub-families, where each family is chosen such that $\alpha^*_i < t$. for various thresholds $t$ defined by the quantiles of $\alpha^*$.  Then the smallest sub-family with the maximal $m_1$ estimate is chosen.
    
**results:** the later procedures discovers more KO groups with higher proportion of defected outcomes.
    
## Code , detailed results and plots:
    
```{r, read_data,echo=FALSE}
rm(list = ls())
## read 0\1 data:
ZO_data <- read.csv(file = "Oct29_2014_Xray_B6N_MGPSelect_Oor1_cleaned.csv") # 8176,79 

## 46 variables of interest:
XrayVariableList <- c("Number.Of.Thoracic.Vertebrae","Number.Of.Lumbar.Vertebrae","Number.Of.Pelvic.Vertebrae","Number.Of.Caudal.Vertebrae", "Transitional.Vertebrae" , "Shape.Of.Vertebrae","Fusion.Of.Vertebrae", "Processes.On.Vertebrae","Maxilla","Zygomatic.Bone","Number.Of.Cervical.Vertebrae","Skull.Shape","Number.Of.Ribs.Right","Number.Of.Ribs.Left","Shape.Of.Ribcage","Shape.Of.Ribs","Rib.Fusions","Clavicle","Scapula"  ,"Humerus","Radius","Ulna","Pelvis","Femur","Tibia","Fibula","Joints","Shape.Of.Spine","Teeth","Mandible","Number.Of.Digits","Digit.Integrity","Syndactylism","Polysyndactylism","Brachydactylism","Kyphosis","Lordosis","Scoliosis","Spinous.Processes","Transverse.Processes","Fusion.Processes","Caudal.Processes","Cervical.Processes","Lumbar.Processes","Sacral.Processes","Thoracic.Processes")    

## remove 3 variables with no values:
XrayVariableList_c <- XrayVariableList[!(XrayVariableList %in% c("Spinous.Processes","Transverse.Processes","Processes.On.Vertebrae"))]

## remove 3 cases with all NA's and leave in variables of interest only:
ZO_data1 <- ZO_data[-which(apply(ZO_data[XrayVariableList_c],1,function(x) all(is.na(x))))
,c("Colony.Prefix","Genotype2","Genotype",XrayVariableList_c)]

# count the number of mices in each KO group (except WT group)
n_t     <- aggregate(. ~ Genotype2 + Colony.Prefix, data = ZO_data1, subset = Genotype2 !="WT",
                     function(x) sum(!is.na(x)),na.action=NULL)
# count the number NAs in each KO group (except WT group)
na_KO <- aggregate(. ~ Genotype2 + Colony.Prefix, data = ZO_data1, subset = Genotype2 !="WT",
                     function(x) sum(is.na(x)),na.action=NULL)

# count the number of mices-marked-with-one in each KO group (except WT group)
n <- aggregate(. ~ Genotype2 + Colony.Prefix,data = ZO_data1,subset = Genotype2 !="WT",
               sum, na.action=NULL, na.rm=T)

# count the number of mices in the WT group
N_minus_n_t <- aggregate(. ~ Genotype2 ,data = ZO_data1,subset = Genotype2 =="WT",
                         function(x) sum(!is.na(x)),na.action=NULL)

# count the number NAs in the WT group
na_WT <- aggregate(. ~ Genotype2 ,data = ZO_data1,subset = Genotype2 =="WT",
                         function(x) sum(is.na(x)),na.action=NULL)

# count the number of mices-marked-with-one in the WT
n_u_minus_n <- aggregate(. ~ Genotype2 ,data = ZO_data1,subset = Genotype2 =="WT",
                         sum, na.action=NULL, na.rm=T)

### Objects dimensions and descriptions:

## n           : 473 X 46 - number of faulted mice in each of the 473 KO (rows) in each outcome (columns)
## n_t         : 473 X 46 - number of tested  mice in each of the 473 KO (rows) in each outcome (columns)
## n_u_minus_n : 1 X 46   - number of faulted WT in each outcome (columns)
## N_minus_n_t : 1 X 46   - number of tested  WT in each outcome (columns)

## na_KO       : 473 X 46 - number of NAs in each KO and outcome
## na_WT       : 1 X 46   - number of NAs in WT for each outcome

### For one outcome (column i)

## n[,i]           : 473 values - number of faulted mice in each of the 473 KO((x = #white balls drawn))
## n_t[,i]         : 473 values - number of tested  mice in each of the 473 KO((k = #balls drawn))
## n_u_minus_n[,i] : one value  - number of faulted WT 
## N_minus_n_t[,i] : one value  - number of tested  WT = 1853

### more notations:

## n_u - faulted mice in total ((m = white balls))
## B   - last value in the support of HG distribution, is min{n_t,n_u} - the minimum between total faults in both groups and tested mice in KO group
```

```{r print_2x2_tables, include=FALSE} 
## print 2X2 table for outcome i and KO j:
ptable <- function(j,i)
{
  n_u1 <- n_u_minus_n[,i]+n[j,i]
  N1 <- N_minus_n_t[,i] + n_t[j,i]
  n_t1 <- n_t[j,i]
  n1  <- pmin(n[j,i],n_t1,n_u1)
  tb <- matrix(c(n1     ,n_u1-n1       ,  n_u1,
               n_t1-n1,N1-n_t1-n_u1+n1,N1-n_u1,
               n_t1   ,N1-n_t1        ,N1),
               nrow=3,ncol=3,byrow=T)
  dimnames(tb) <- list("Defected"=c("Y","N","TOTAL"),
                       "Group"=c("KO","WT","TOTAL"))
  tbna <- matrix(c(na_KO[j,i],na_WT[,i],na_KO[j,i]+na_WT[,i]),nrow=1,ncol=3,byrow=T)
  dimnames(tbna) <- list("#NAs","Group"=c("KO","WT","TOTAL"))
  print(tb)
  print(tbna)
}

ptable(4,4)
ptable(8,8)
ptable(10,10)
```

```{r aggregate_over_all_outcomes,echo=FALSE}
## reshape data for analysis of all KO together
vec_n_t         <- as.vector(as.matrix(n_t[-(1:3)]))
vec_na_KO       <- as.vector(as.matrix(na_KO[-(1:3)]))
vec_n           <- as.vector(as.matrix(n[-(1:3)]))
vec_N_minus_n_t <- rep(as.vector(as.matrix(N_minus_n_t[-(1:3)])),each=nrow(n))
vec_na_WT       <- rep(as.vector(as.matrix(na_WT[-(1:3)])),each=nrow(n))
vec_n_u_minus_n <- rep(as.vector(as.matrix(n_u_minus_n[-(1:3)])),each=nrow(n))

# ## reference:
# a=matrix(1:15,ncol=3)
# 
# dimnames(a) <- list("KO"=1:5,"OUTCOMES"=1:3)
# a
# (va <- as.vector(a))
# 
# b=matrix(c(1,6,11),ncol=3)
# b
# (vb <- as.vector(b))
# 
# rbind(va,vb) # not desired result
# 
# repb <- rep(vb, each=nrow(a)) # use 'each' argument
# 
# rbind(va,repb) # OK

```


```{r}
## function to calculate the size of the Tarone family,
## finds K(alpha)=inf{1:j|m(alpha,j)<=j} where m(alpha,j)=#{i|alpha_star[i]<=alpha/j}
findK <- function(alpha_star,alpha=0.05,verbose=T)
{
  la    <- length(alpha_star) 
  m     <- vector(length=la)
  for (j in 1:la)    m[j] <- sum(alpha_star<=(alpha/j))
  K <- (1:la)[which(m<=(1:la))[1]]
  if (is.na(K)) stop("something is wrong, check alpha_star for NAs and findK() definition")
  if (verbose) cat("K = ",K,"\n")
  return (K)
}

Pi_0_est_EU <- function(p,f_n,kappa,in_fam,lambda)
{
  m_tag <- sum(in_fam)
  lpl <- (lambda < p[in_fam]) & (p[in_fam] <= lambda + kappa[in_fam]*f_n[in_fam])
  EU_ecdf_lambda <- (sum(p[in_fam]<=lambda))/m_tag + (sum(1 - (p[in_fam][lpl]-lambda) / (kappa[in_fam][lpl]*f_n[in_fam][lpl]) ))/m_tag
  EU_Pi_0_hat <- (1-EU_ecdf_lambda)/(1-lambda)
  return(EU_Pi_0_hat)
}

Pi_0_est_prand <- function(p,f_n,kappa,in_fam,lambda)
{
  m_tag <- sum(in_fam)
  lpl <- (lambda < p[in_fam]) & (p[in_fam] <= lambda + kappa[in_fam]*f_n[in_fam])
  EU_ecdf_lambda <- (sum(p[in_fam]<=lambda))/m_tag + (sum(1 - (p[in_fam][lpl]-lambda) / (kappa[in_fam][lpl]*f_n[in_fam][lpl]) ))/m_tag
  EU_Pi_0_hat <- (1-EU_ecdf_lambda)/(1-lambda)
  return(EU_Pi_0_hat)
}


## fix tunning parameter lambda for pi_0 estimation (Sarkar 2004, Dickhaus 2012):
lambda <- 0.05

## initialize objects:
alpha_star<-p<-p_rand<-pa_BH<-pa_BH_0.05<-pa_Gilb<-pa_new<-m1_hat<- rep(NA,length(vec_n))
size_F_0.05 <- K <- argmax_m1_hat<-  NA

## work with phyper() notation:
mm <- vec_n_u_minus_n + vec_n
nn <- vec_N_minus_n_t + vec_n_t - mm
kk  <- vec_n_t
BB  <- pmin(mm,kk)
stopifnot(vec_n<=BB)
xx  <- pmin(vec_n,BB)

## get pv (right tail) and alpha star:
p  <- dhyper(x = xx, m = mm, n = nn, k = kk) + phyper(q = xx, m = mm, n = nn, k = kk, lower.tail = FALSE)
alpha_star <- dhyper(x=BB, m = mm, n = nn, k = kk)

## get highest pdf value within the pv region:
f_n <- dhyper(x = xx, m = mm, n = nn, k = kk)
## get number of occurences of this highest value (usually one):
kappa <- apply(cbind(BB,mm,nn,kk,f_n),1,
             function(x) sum(dhyper(x = 0:x[1], m = x[2], n = x[3], k = x[4])==x[5]))

## BH adjustment:
pa_BH              <- p.adjust(p,"BH")

## BH on "minimum attainable pv" ( alpha_star) smaller than 0.05:
F_0.05             <- alpha_star<=0.05
size_F_0.05        <- sum(F_0.05)
pa_BH_0.05         <- rep(1,length(F_0.05))
pa_BH_0.05[F_0.05] <- p.adjust(p[F_0.05],"BH")

## BH on Tarone family:
K               <- findK(alpha_star)
F_Gilb          <- alpha_star<=0.05/K
pa_Gilb         <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p.adjust(p[F_Gilb],"BH")

## estimation of m1 for each sub-family thresholded by alpha_star
t <- sort(alpha_star)
for (j in 1:length(t))
{
  in_fam <- alpha_star <= t[j]
  Pi_0_hat_EU <- EU_Pi_0_est(p = pp,f_n = f_n,kappa = kappa,in_fam = in_fam,lambda = lambda))
  m1_hat[j]  <- m_tag*(1-Pi_0_hat_EU)
  if (!(j%%10)) cat(j,"\n")
}
save(m1_hat,file = "m1_hat.RData")

#1. choice of optimum sub family:
argmax_m1_hat <-  #which.max(m1_hat)

F_new <- alpha_star <= t[argmax_m1_hat]
sum(F_new)
pa_new <- rep(1,length(F_new))
pa_new[F_new] <- p.adjust(p[F_new],"BH")

#2. summaries rejections: 
sum(pa_Gilb<=0.05)
sum(pa_BH_0.05<=0.05)
sum(pa_Gilb<=0.05)
sum(pa_new<=0.05)

#3. plot pv:

plot(sort(p),type="l")
plot(sort(alpha_star),type="l")
plot(m1_hat,type="l")

#4. name the results and show tables to diagnoze anomalities

#5. repeat with Estimate m0 (prand) and adaptive plugin procedure lambda=0.05,0.5

#6. mid p-values in the four (non-adaptive) procedures. 

#7. Use randomized p-values in the four (non-adaptive) procedures.

#8. Use realized randomized p-values in the four (non-adaptive) procedures.

# ** show results in the report as : table with # rejections in each proc 4families(BH, BH0,05, Gilbert, m1est) * 6 (non-adaptive, adaptive 0.05, adaptive 0.5, mid pv , realized randomized , repeated realized randomized )

#***. repeat analysis for each group separatly + corction  as in marinas method

xxx <- rhyper(nn = length(xx), m = mm, n = nn, k = kk)

## get pv (right tail) and alpha star:
pp  <- dhyper(x = xxx, m = mm, n = nn, k = kk) + phyper(q = xxx, m = mm, n = nn, k = kk, lower.tail = FALSE)
alpha_star <- dhyper(x=BB, m = mm, n = nn, k = kk)

## get highest pdf value within the pv region:
f_n <- dhyper(x = xxx, m = mm, n = nn, k = kk)
## get number of occurences of this highest value (usually one):
kappa <- apply(cbind(BB,mm,nn,kk,f_n),1,
             function(x) sum(dhyper(x = 0:x[1], m = x[2], n = x[3], k = x[4])==x[5]))

in_fam <- alpha_star <= 1
(EU_Pi_0_hat <- EU_Pi_0_est(p = pp,f_n = f_n,kappa = kappa,in_fam = in_fam,lambda = lambda))
  m1_hat[j]  <- m_tag*(1-EU_Pi_0_hat)

## BH adjustment:
pa_BH <- p.adjust(pp,"BH")


```


```{r}


## function to calculate the size of the Tarone family:
findK <- function(alpha_star,alpha=0.05,range = NULL,verbose=T)
  # finds K(alpha)=inf{1:j|m(alpha,j)<=j} where m(alpha,j)=#{i|alpha_star[i]<=alpha/j}
{
  la <- length(alpha_star) 
  if (is.null(range))
    range <- 1:la
  m <- vector(length=la)
  for (j in range)
  {
    m[j] <- sum(alpha_star<=(alpha/j))
    #cat("j: ",j," m[j]:",m[j],"\n")
  }
  K <- (1:la)[which(m<=(1:la))[1]]
  if (verbose) cat("K = ",K,"\n")
  return (K)
}

lambda <- 0.05

alpha_star<-p<-p_rand<-pa_BH<-pa_BH_0.05<-pa_Gilb<-pa_new<-m1_hat<- matrix(NA,nrow = nrow(n), ncol = ncol(n))
size_F_0.05 <- K <- argmax_m1_hat<-  rep(NA,ncol(n))

for (i in 4:46)
{i=4
  # work with phyper() notation:
  mm <- n_u_minus_n[,i]+n[,i]
  nn <- N_minus_n_t[,i] + n_t[,i] - mm
  kk  <- n_t[,i]
  BB  <- pmin(mm,kk)
  stopifnot(n[,i]<=BB)
  xx  <- pmin(n[,i],BB)
  
  # get pv (right tail) and alpha star:
  p[,i]  <- dhyper(x = xx, m = mm, n = nn, k = kk) + phyper(q = xx, m = mm, n = nn, k = kk, lower.tail = FALSE)
  alpha_star[,i] <- dhyper(x=BB, m = mm, n = nn, k = kk)

  f_n <- dhyper(x = xx, m = mm, n = nn, k = kk)
  kappa <- apply(cbind(BB,mm,nn,kk,f_n),1,
               function(x) sum(dhyper(x = 0:x[1], m = x[2], n = x[3], k = x[4])==x[5]))

  # BH adjustment:
  pa_BH[,i] <- p.adjust(p[,i],"BH")
  
  # BH on minimum attainble pv smaller than sig. level 0.05:
  F_0.05 <- alpha_star[,i]<=0.05
  size_F_0.05[i] <- sum(F_0.05)
  pa_BH_0.05[,i] <- 1
  pa_BH_0.05[F_0.05,i] <- p.adjust(p[F_0.05,i],"BH")
  
  # BH on Tarone family:
  K[i] <- findK(alpha_star[,i])
  F_Gilb <- alpha_star[,i]<=0.05/K[i]
  pa_Gilb[,i] <- 1
  pa_Gilb[F_Gilb,i] <- p.adjust(p[F_Gilb,i],"BH")
  
  # estimation of m1 for each sub-family thresholded by alphastar
  t <- sort(alpha_star[,i])
  for (j in 1:length(t))
    {j=200
    in_fam <- alpha_star[,i] <= t[j]
    m_tag <- sum(in_fam)
    
    lpl <- (lambda < p[in_fam,i]) & (p[in_fam,i] <= lambda + kappa[in_fam]*f_n[in_fam])
    EU_ecdf_lambda <- (sum(p[in_fam,i]<=lambda))/m_tag + (sum(1 - (p[lpl,i]-lambda) / (kappa[lpl]*f_n[lpl]) ))/m_tag
           
    EU_Pi_0_hat <- (1-EU_ecdf_lambda)/(1-lambda)
    
    m1_hat[,i]  <- m_tag*(1-EU_Pi_0_hat)
    }
  # choice of optimum sub family:
  argmax_m1_hat[i] <- which.max(m1_hat[,i])
  
  F_new <- alpha_star[,i]<=t[argmax_m1_hat[i]]
  pa_new[,i] <- 1
  pa_new[F_new,i] <- p.adjust(p[F_new,i],"BH")
}
m1_hat


Rej <- data.frame(size_F_0.05,K,argmax_m1_hat,BH=apply(pa_BH,2,function(x) sum(x<=0.05)),BH0.05=apply(pa_BH_0.05,2,function(x) sum(x<=0.05)),Gilbert=apply(pa_Gilb,2,function(x) sum(x<=0.05)),m1est=apply(pa_new,2,function(x) sum(x<=0.05)))[-(1:3),]

Rejdiff <- data.frame("BH0.05--BH"=Rej[3+2]-Rej[3+1],"Gilb--BH"=Rej[3+3]-Rej[3+1],"m1est--BH"=Rej[3+4]-Rej[3+1])
rownames(Rej) <- XrayVariableList_c
rownames(Rejdiff) <- XrayVariableList_c

Rej
colSums(Rej)
Rejdiff
colSums(Rejdiff)  
```


```{r echo=FALSE}
#   # kk<=mm
#   mm <- 7
#   nn <- 10
#   kk <- 6
#   B <- min(kk,mm)
#   xx <- 4:B
#   
#   dhyper(x=xx, m = mm, n = nn, k = kk)
#   choose(mm,xx)*choose(nn,kk-xx)/choose(mm+nn,kk)
#   choose(mm,kk)/choose(mm+nn,kk)
#   
#   # kk>mm
#   mm <- 7
#   nn <- 10
#   kk <- 8
#   B <- min(kk,mm)
#   xx <- 4:B
#   
#   dhyper(x=xx, m = mm, n = nn, k = kk)
#   choose(mm,xx)*choose(nn,kk-xx)/choose(mm+nn,kk)
#   choose(nn,kk-mm)/choose(mm+nn,kk)

```

```{r,fig.height=16,fig.width=7,echo=FALSE}
#  plots:
par(mfrow=c(2,3))
for (i in 3+(1:43))
{
  plot(sort(p[,i]),type="l",main = "p-value")
  plot(sort(alpha_star[,i]),type="l",main = "alpha_star")
#   asf <- table(alpha_star[,i])
#   asv <- as.numeric(names(asf))
#   plot(asv,cumsum(asf),type="h",lwd=1,col="darkgrey",xlab="x",ylab="counts")
  plot(m1_hat[,i],type="l",main = "m1 hat ")
  abline(v=c(size_F_0.05[i],K[i],argmax_m1_hat[i]),col=c("brown","red","orange"))
}
```

