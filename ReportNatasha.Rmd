---
title: "Title"
author: "R.H; S.Y"
date: "Tuesday, Feb 03, 2015"
output:
  pdf_document:
---

```{r knitr_options, include=FALSE}
rm(list = ls())
library(knitr)
library(partitions)
library(dplyr)
library(tidyr)

opts_chunk$set(include = FALSE,echo = FALSE, eval = FALSE)
```

```{r read_data}
## read 0\1 data:
ZO_data <- tbl_df(read.csv(file = "Oct29_2014_Xray_B6N_MGPSelect_Oor1_cleanV2.csv"))

## 46 variables of interest:
XrayVariableList <- c("Number.Of.Thoracic.Vertebrae","Number.Of.Lumbar.Vertebrae","Number.Of.Pelvic.Vertebrae","Number.Of.Caudal.Vertebrae", "Transitional.Vertebrae" , "Shape.Of.Vertebrae","Fusion.Of.Vertebrae", "Processes.On.Vertebrae","Maxilla","Zygomatic.Bone","Number.Of.Cervical.Vertebrae","Skull.Shape","Number.Of.Ribs.Right","Number.Of.Ribs.Left","Shape.Of.Ribcage","Shape.Of.Ribs","Rib.Fusions","Clavicle","Scapula"  ,"Humerus","Radius","Ulna","Pelvis","Femur","Tibia","Fibula","Joints","Shape.Of.Spine","Teeth","Mandible","Number.Of.Digits","Digit.Integrity","Syndactylism","Polysyndactylism","Brachydactylism","Kyphosis","Lordosis","Scoliosis","Spinous.Processes","Transverse.Processes","Fusion.Processes","Caudal.Processes","Cervical.Processes","Lumbar.Processes","Sacral.Processes","Thoracic.Processes")

## remove 3 variables with no values:
XrayVariableList_c <- XrayVariableList[!c(XrayVariableList %in% c("Spinous.Processes","Transverse.Processes","Processes.On.Vertebrae"))]

f <- function(x){ sum(is.na(x))}

(ZO_data1 <- ZO_data %>%
   ## keep variables of interest only and 3 indices : 
   select(one_of(c("Colony.Prefix","Genotype2","Gender",XrayVariableList_c))) %>%  
   ## reshape the data from wide (outcomes in 43 columns) to long (outcomes as variable)  
   gather(Outcome,zo,-Colony.Prefix,-Genotype2,-Gender) %>% 
   ## create "group" variable to contain the data from both "Genotype2" & "Colony.Prefix" :
   mutate(Group = as.factor(ifelse(Genotype2 == "WT","WT",paste0(Colony.Prefix,"_",Genotype2)))) %>%
   ## drop "Genotype2" & "Colony.Prefix" : 
   mutate(Genotype2 = NULL, Colony.Prefix = NULL) %>%
   ## group by ...
   group_by(Outcome,Gender,Group) %>% 
   ## and summarise sums, counts and NAs:
   summarise(s = sum(),n = n() , NAs = sum(is.na(zo))))

KOs_only <- filter(ZO_data1, Group != "WT")
WTs_only <- filter(ZO_data1, Group == "WT")
FM_together <- full_join(KOs_only,WTs_only,by = c("Outcome","Gender"))

F_only <- filter(FM_together, Gender == "Female")
M_only <- filter(FM_together, Gender == "Male")
tbl_222 <- full_join(F_only,M_only,by = c("Outcome","Group.x","Group.y")) %>% 
  select(Outcome, Group = Group.x,
         n111 = s.x.x, n.11 = n.x.x, n121 = s.y.x, n.21 = n.y.x,
         n112 = s.x.y, n.12 = n.x.y, n122 = s.y.y, n.21 = n.y.y)

## # of mices in KO
n.1.     <- aggregate(. ~ Genotype2 + Colony.Prefix + Gender, data = ZO_data1, subset = Genotype2 !="WT",function(x) sum(!is.na(x)),na.action=NULL)

n.11_and_n.12 <- merge(x = n.1.[n.1.$Gender=="Male",],y = n.1.[n.1.$Gender=="Female",],by = c("Colony.Prefix","Genotype2"), all = T, suffixes = c(".Male",".Female"),sort = T)

## # of NAs in KO
n.1._NA <- aggregate(. ~ Genotype2 + Colony.Prefix + Gender, data = ZO_data1, subset = Genotype2 !="WT", function(x) sum(is.na(x)),na.action=NULL)

n.11_and_n.12_NA <- merge(x = n.1._NA[n.1._NA$Gender=="Male",],y = n.1._NA[n.1._NA$Gender=="Female",],by = c("Colony.Prefix","Genotype2"), all = T, suffixes = c(".Male",".Female"),sort = T)

## # of deformed in KO
n11. <- aggregate(. ~ Genotype2 + Colony.Prefix + Gender,data = ZO_data1,subset = Genotype2 !="WT",sum, na.action=NULL, na.rm=T)

n111_and_n112 <- merge(x = n11.[n11.$Gender=="Male",],y = n11.[n11.$Gender=="Female",],by = c("Colony.Prefix","Genotype2"), all = T, suffixes = c(".Male",".Female"),sort = T)

## # of mices in WT
n.2. <- aggregate(. ~ Genotype2 + Gender,data = ZO_data1,subset = Genotype2 =="WT",                 function(x) sum(!is.na(x)),na.action=NULL)

n.21_and_n.22 <- merge(x = n.2.[n.2.$Gender=="Male",],y = n.2.[n.2.$Gender=="Female",],by = "Genotype2", all = T, suffixes = c(".Male",".Female"),sort = T)

## # of NAs in WT
n.2._NA <- aggregate(. ~ Genotype2 + Gender,data = ZO_data1,subset = Genotype2 =="WT",
                         function(x) sum(is.na(x)),na.action=NULL)

n.21_and_n.22_NA <- merge(x = n.2._NA[n.2._NA$Gender=="Male",],y = n.2._NA[n.2._NA$Gender=="Female",],by = "Genotype2", all = T, suffixes = c(".Male",".Female"),sort = T)

## # of deformed in WT groups
n12. <- aggregate(. ~ Genotype2 + Gender,data = ZO_data1,subset = Genotype2 =="WT",
                         sum, na.action=NULL, na.rm=T)

n121_and_n122 <- merge(x = n12.[n12.$Gender=="Male",],y = n12.[n12.$Gender=="Female",],by = "Genotype2", all = T, suffixes = c(".Male",".Female"),sort = T)


# ---------------- reshape data for OUTCOMEs to appear in one column together: ---------

vec_n.11_and_n.12    <- cbind(as.vector(as.matrix(n.11_and_n.12[,4:46])),
                              as.vector(as.matrix(n.11_and_n.12[,48:90])))
vec_n.11_and_n.12_NA <- cbind(as.vector(as.matrix(n.11_and_n.12_NA[,4:46])),
                              as.vector(as.matrix(n.11_and_n.12_NA[,48:90])))
vec_n111_and_n112    <- cbind(as.vector(as.matrix(n111_and_n112[,4:46])),
                              as.vector(as.matrix(n111_and_n112[,48:90])))
vec_n.21_and_n.22    <- cbind(rep(as.vector(as.matrix(n.21_and_n.22[,4:46])),each=nrow(n111_and_n112)),
                              rep(as.vector(as.matrix(n.21_and_n.22[,48:90])),each=nrow(n111_and_n112)))
vec_n.21_and_n.22_NA <- cbind(rep(as.vector(as.matrix(n.21_and_n.22_NA[,4:46])),each=nrow(n111_and_n112)),
                              rep(as.vector(as.matrix(n.21_and_n.22_NA[,48:90])),each=nrow(n111_and_n112)))
vec_n121_and_n122    <- cbind(rep(as.vector(as.matrix(n121_and_n122[,4:46])),each=nrow(n111_and_n112)),
                              rep(as.vector(as.matrix(n121_and_n122[,48:90])),each=nrow(n111_and_n112)))
# ---------------- reshape data each 2X2X2 table in a row: ---------

tbl_2X2X2 <-  cbind(vec_n111_and_n112[,1], vec_n.11_and_n.12[,1]-vec_n111_and_n112[,1],
              vec_n121_and_n122[,1], vec_n.21_and_n.22[,1]-vec_n121_and_n122[,1],
              vec_n111_and_n112[,2], vec_n.11_and_n.12[,2]-vec_n111_and_n112[,2],
              vec_n121_and_n122[,2], vec_n.21_and_n.22[,2]-vec_n121_and_n122[,2])

tbl_2X2X2[is.na(tbl_2X2X2)] <- 0

summary(tbl_2X2X2)

# z_format <- array(c("n111", "n211", "n121", "n221","n112", "n212", "n122", "n222"), dim=c(2, 2, 2))

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 2X2 contingency tables:

# older natation:
# |  |1-deformed|0 |    |
# |--|:--:|:--:|:--:|
# |KO|$n$ |$n1..-n$|$n1..$|
# |WT|$n_u-n$|$N-n1..-n_u+n$|$N-n1..$|
# |  |$n_u$|$N-n_u$|$N$

# new notation:
# Male: n..1
# |  |KO  |WT  |    |
# |--|:--:|:--:|:--:|
# |1 |n111|n121|n1.1|
# |0 |n211|n221|n2.1|
# |  |n.11|n.21|n..1|

# Female: n..2
# |  |KO  |WT  |    |
# |--|:--:|:--:|:--:|
# |1 |n112|n122|n1.2|
# |0 |n212|n222|n2.2|
# |  |n.12|n.22|n..2|
```

```{r functions_definitions}
# ---------------- functions definitions: -----------------------------------------

mod.zelen.test<-function (z, example=F) 
{
  # Zelen's test.
  # Based on chapter 10 of:
  #
  #   Nonparametric Statistical Methods, 3e
  #   Hollander, Wolfe & Chicken 
  #
  # The data z is an array of k 2x2 matrices.
  # Small data sets only!
  # Uses package "partitions".
  #
  # Inefficiently programmed by Eric Chicken, November 2012.
  
 
  if(example) z <- array(c(2, 1, 2, 5, 1, 5, 4, 1), dim=c(2, 2, 2))
  
  s <- sum(z[1, 1, ])
  k <- dim(z)[3]
  
  # blockparts is from package "partitions".  This is where large data
  # sets will be an issue.
  # Make sure that each part of the sum is no more than the column or
  # row margin total.
  bp <- numeric(0)
  for(i in 1:k) bp <- c(bp, min(sum(z[1,,i]),sum(z[,1,i])))
  a <- blockparts(bp, s)
  
  y <- numeric(0)
  for(i in 1:dim(a)[2])
  {
    is.tau.0 <- T
    x <- numeric(0)
    for(j in 1:k)
    {
      O.11 <- a[j, i]
      O.12 <- sum(z[1, , j]) - O.11
      O.21 <- sum(z[, 1, j]) - O.11
      O.22 <- sum(z[2, , j]) - O.21
      tau <- matrix(c(O.11, O.12, O.21, O.22), nrow=2, byrow=T)
      if(sum(tau == z[, , j]) < 4) is.tau.0 <- F
      n1 <- O.11 + O.12
      n2 <- O.21 + O.22
      n.1 <- O.11 + O.21
      n <- n1 + n2
      x.j <- choose(n1, O.11) * choose(n2, O.21) / choose(n, n.1)
      x <- c(x, x.j)
    }
    if(is.tau.0) tau.0 <- i
    y <- c(y, prod(x))
  }
  y <- y / sum(y)
  p <- sum(y[y<=y[tau.0]])
  alpha_star <- min(y)
  f_n <- unique(y[y==y[tau.0]])
  kappa  <- sum(y==y[tau.0])

  return(list(p=p,alpha_star=alpha_star,f_n=f_n,kappa=kappa))
}

## get size of the Tarone family, given alpha_stars: 
# finds K(alpha)=inf{1:j|m(alpha,j)<=j} where m(alpha,j)=#{i|alpha_star[i]<=alpha/j}
findK <- function(alpha_star,alpha,verbose=T)
{
  la    <- length(alpha_star) 
  m     <- vector(length=la)
  for (j in 1:la)    m[j] <- sum(alpha_star<=(alpha/j))
  if (m[1]==0) K <- 0 else
    K <- (1:la)[which(m<=(1:la))[1]]
  if (is.na(K)) stop("something is wrong, check alpha_star for NAs and findK() definition")
  if (verbose) cat("K = ",K,"\n")
  return (K)
}

# estimate pi0 conditional expectation over U[0,1] (Dickhaus 2012):
Pi_0_est_EU <- function(p,f_n,kappa,in_fam,lambda)
{
  ## size of the sub-family:
  m_tag <- sum(in_fam)
  ## logical vector of size of in_fam that indicates where p-value is between lambda and lambda + next step in pdf:
  lpl <- (lambda < p[in_fam]) & (p[in_fam] <= lambda + kappa[in_fam]*f_n[in_fam])
  ## formula for the conditional expectation over uniform (0,1):
  ecdf_lambda_EU <- (sum(p[in_fam]<=lambda))/m_tag + (sum(1 - (p[in_fam][lpl]-lambda) / (kappa[in_fam][lpl]*f_n[in_fam][lpl]) ))/m_tag
  ## and the expectation of the pi_0 estimate
  Pi_0_hat_EU <- (1-ecdf_lambda_EU)/(1-lambda)
  return(Pi_0_hat_EU)
}

# adaptive BH given pi0 estimate: 
p_adjust_adaptive <- function(p,pi_0_hat)
{
  lp <- length(p)
  i <- lp:1L
  o <- order(p, decreasing = TRUE)
  ro <- order(o)
  pmin(1, cummin(lp*pi_0_hat/i * p[o]))[ro]
}

## print 2X2 table for OUTCOME j and KO i:
ptable <- function(i,j)
{
  n_u1 <- n_u_minus_n[1,3+j]+n[i,3+j]
  N1 <- N_minus_n1..[1,3+j] + n1..[i,3+j]
  n1..1 <- n1..[i,3+j]
  n1  <- n[i,3+j]
  tb <- matrix(c(n1     ,n_u1-n1       ,  n_u1,
               n1..1-n1,N1-n1..1-n_u1+n1,N1-n_u1,
               n1..1   ,N1-n1..1        ,N1),
               nrow=3,ncol=3,byrow=T)
  dimnames(tb) <- list("Defected"=c("Y","N","TOTAL"),
                       "Group"=c("KO","WT","TOTAL"))
  tbna <- matrix(c(na_KO[i,3+j],na_WT[1,3+j],na_KO[i,3+j]+na_WT[i,3+j]),nrow=1,ncol=3,byrow=T)
  dimnames(tbna) <- list("#NAs","Group"=c("KO","WT","TOTAL"))
  return(tb)
}

```

```{r all_outcomes_together_analysis}
lambda <- 0.05
alpha  <- 0.05

# # ---------------- get statistics: ---------------------------------------
# 
# ## work with phyper() notation:
# mm <- vec_n_u_minus_n + vec_n
# nn <- vec_N_minus_n1.. + vec_n1.. - mm
# kk  <- vec_n1..
# BB  <- pmin(mm,kk)
# xx  <- pmin(vec_n,BB)
# 
# ## get pv (right tail)
# p  <- dhyper(x = xx, m = mm, n = nn, k = kk) + phyper(q = xx, m = mm, n = nn, k = kk, lower.tail = FALSE)
# 
# ## get "alpha star" (the minimum attainable p-value due to discreteness):
# alpha_star <- dhyper(x=BB, m = mm, n = nn, k = kk)
# 
# ## get the highest pdf value within the observed significance:
# f_n <- dhyper(x = xx, m = mm, n = nn, k = kk)
# 
# ## get the number of occurences of this value (usually one):
# kappa <- apply(cbind(BB,mm,nn,kk,f_n),1,
#              function(x) sum(dhyper(x = 0:x[1], m = x[2], n = x[3], k = x[4])==x[5]))
stat <- data.frame(p=NA,alpha_star=NA,f_n=NA,kappa=NA)
for (i in 1:nrow(tbl_2X2X2))
  stat[i,] <- mod.zelen.test(array(tbl_2X2X2[i,],dim = c(2,2,2))) 

summary(stat)

mod.zelen.test(z = NULL, example = T)


# ---------- sub families sizes and indices: --------------------------- 

F_alpha       <- alpha_star <= alpha
size_F_alpha  <- sum(F_alpha)
K             <- 12125 # findK(alpha_star)
F_Gilb        <- alpha_star <= alpha/K

fam_size             <- c(length(p),size_F_alpha,K)

# ---------- Adjustment 1 original pv -------------------

## BH adjustment:
pa_BH <- p.adjust(p,"BH")

## BH on alpha_star-smaller-than-alpha:
pa_BH_alpha <- rep(1,length(F_alpha))
pa_BH_alpha[F_alpha] <- p.adjust(p[F_alpha],"BH")

## BH on Tarone family:
pa_Gilb <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p.adjust(p[F_Gilb],"BH")

pa_1 <- cbind(pa_BH,pa_BH_alpha,pa_Gilb)

# ---------- Adjustment 2 : adaptive pv -------------------
# get pi_0 estimates for each sub family:
pi_0_all   <- Pi_0_est_EU(p,f_n,kappa,in_fam = rep(T,length(p)),lambda = lambda)
pi_0_alpha <- Pi_0_est_EU(p,f_n,kappa,in_fam = F_alpha,lambda = lambda)
pi_0_Tar   <- Pi_0_est_EU(p,f_n,kappa,in_fam = F_Gilb ,lambda = lambda)

pi0 <- c(pi_0_all,pi_0_alpha,pi_0_Tar)


# adjustment:
pa_BH      <- p_adjust_adaptive(p = p, pi_0_hat = pi_0_all)

pa_BH_alpha <- rep(1,length(F_alpha))
pa_BH_alpha[F_alpha] <- p_adjust_adaptive(p = p[F_alpha], pi_0_hat = pi_0_alpha)

pa_Gilb    <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb]      <- p_adjust_adaptive(p = p[F_Gilb] , pi_0_hat = pi_0_Tar)

pa_2  <- cbind(pa_BH,pa_BH_alpha,pa_Gilb)

# ---------- Adjustment 3 : mid pv --------------------------------
p_mid <- p - f_n*0.5

pa_BH <- p.adjust(p_mid,"BH")

pa_BH_alpha <- rep(1,length(F_alpha))
pa_BH_alpha[F_alpha] <- p.adjust(p_mid[F_alpha],"BH")

pa_Gilb <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p.adjust(p_mid[F_Gilb],"BH")

pa_3  <- cbind(pa_BH,pa_BH_alpha,pa_Gilb)

# ---------- Adjustment 2 : adaptive pv -------------------
pa_BH       <- p_adjust_adaptive(p = p_mid, pi_0_hat = pi_0_all)

pa_BH_alpha <- rep(1,length(F_alpha))
pa_BH_alpha[F_alpha] <- p_adjust_adaptive(p = p_mid[F_alpha], pi_0_hat = pi_0_alpha)

pa_Gilb     <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p_adjust_adaptive(p = p_mid[F_Gilb] , pi_0_hat = pi_0_Tar)

pa_4 <- cbind(pa_BH,pa_BH_alpha,pa_Gilb)

#-------------------- summarize results: ---------------------------

tb_all <- cbind(fam_size,pi0,
      apply(pa_1,2,function(x) sum(x<=alpha)),
      apply(pa_2,2,function(x) sum(x<=alpha)),
      apply(pa_3,2,function(x) sum(x<=alpha)),
      apply(pa_4,2,function(x) sum(x<=alpha)))

oc_ind <- rep(1:43,each=473)

tb_rej_in_each_oc_0_05 <- cbind(tapply(pa_1[,2],oc_ind,function(x) sum(x<=alpha)),
                         tapply(pa_2[,2],oc_ind,function(x) sum(x<=alpha)),
                         tapply(pa_3[,2],oc_ind,function(x) sum(x<=alpha)),
                         tapply(pa_4[,2],oc_ind,function(x) sum(x<=alpha)))
tb_rej_in_each_oc_Gilb <- cbind(tapply(pa_1[,3],oc_ind,function(x) sum(x<=alpha)),
                         tapply(pa_2[,3],oc_ind,function(x) sum(x<=alpha)),
                         tapply(pa_3[,3],oc_ind,function(x) sum(x<=alpha)),
                         tapply(pa_4[,3],oc_ind,function(x) sum(x<=alpha)))

save(tb_all,tb_rej_in_each_oc_0_05,tb_rej_in_each_oc_Gilb,file="tables_all.RData")

```

```{r each_OC_separately_function}
main_proc <- function(p,alpha_star,f_n,kappa,alpha,lambda)
{
# ---------- sub families sizes and indices: --------------------------- 
#browser()
F_alpha       <- alpha_star <= alpha
size_F_alpha  <- sum(F_alpha)
K             <- findK(alpha_star,alpha)
if (K==0) F_Gilb <- rep(F,length(alpha_star)) else
  F_Gilb <- alpha_star <= alpha/K
fam_size      <- c(size_F_alpha,K)

# ---------- Adjustment 1 original pv -------------------
## BH on alpha_star-smaller-than-alpha:
pa_BH_alpha <- rep(1,length(F_alpha))
pa_BH_alpha[F_alpha] <- p.adjust(p[F_alpha],"BH")

## BH on Tarone family:
pa_Gilb <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p.adjust(p[F_Gilb],"BH")

pa_1 <- cbind(pa_BH_alpha,pa_Gilb)

# ---------- Adjustment 2 : adaptive pv -------------------
# get pi_0 estimates for each sub family:
if (size_F_alpha<50) pi_0_alpha <- NA else
  pi_0_alpha <- Pi_0_est_EU(p,f_n,kappa,in_fam = F_alpha,lambda = lambda)
if (K<50) pi_0_Tar <- NA else
  pi_0_Tar   <- Pi_0_est_EU(p,f_n,kappa,in_fam = F_Gilb ,lambda = lambda)

pi0 <- c(pi_0_alpha,pi_0_Tar)

# adjustment:
pa_BH_alpha <- rep(1,length(F_alpha))
pa_BH_alpha[F_alpha] <- p_adjust_adaptive(p = p[F_alpha], pi_0_hat = pi_0_alpha)

pa_Gilb    <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p_adjust_adaptive(p = p[F_Gilb] , pi_0_hat = pi_0_Tar)

pa_2 <- cbind(pa_BH_alpha,pa_Gilb)

# ---------- Adjustment 3 : mid pv --------------------------------
p_mid <- p - f_n*0.5

pa_BH_alpha <- rep(1,length(F_alpha))
pa_BH_alpha[F_alpha] <- p.adjust(p_mid[F_alpha],"BH")

pa_Gilb <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p.adjust(p_mid[F_Gilb],"BH")

pa_3  <- cbind(pa_BH_alpha,pa_Gilb)

# ---------- Adjustment 2 : adaptive pv -------------------
pa_BH_alpha <- rep(1,length(F_alpha))
pa_BH_alpha[F_alpha] <- p_adjust_adaptive(p = p_mid[F_alpha], pi_0_hat = pi_0_alpha)

pa_Gilb     <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p_adjust_adaptive(p = p_mid[F_Gilb] , pi_0_hat = pi_0_Tar)

pa_4 <- cbind(pa_BH_alpha,pa_Gilb)

#-------------------- summarize results: ---------------------------

tb <- cbind(fam_size,pi0,
            apply(pa_1,2,function(x) sum(x<=alpha)),
            apply(pa_2,2,function(x) sum(x<=alpha)),
            apply(pa_3,2,function(x) sum(x<=alpha)),
            apply(pa_4,2,function(x) sum(x<=alpha)))

return(tb)
}

```

```{r each_OC_separately_exe}
alpha <- 0.05
tb_each_oc_sep_0_05 <- NULL
for (i in 1:43)
  {
  OC_inds  <- 1:473 + 473*(i-1)
  tb <- main_proc(p = p[OC_inds],
                  alpha_star = alpha_star[OC_inds],
                  f_n = f_n[OC_inds],
                  kappa = kappa[OC_inds],
                  alpha = alpha,lambda = lambda)
  tb_each_oc_sep_0_05 <- rbind(tb_each_oc_sep_0_05,tb)
  }

tb_each_oc_sep_0_05_Total_of_BH_0.05 <- c(NA,NA,colSums(tb_each_oc_sep_0_05[2*(1:43)-1,3:6],na.rm = T))
tb_each_oc_sep_0_05_Total_of_Gilbert <- c(NA,NA,colSums(tb_each_oc_sep_0_05[2*(1:43)  ,3:6],na.rm = T))
tb_each_oc_sep_0_05_with_totals <- rbind(tb_each_oc_sep_0_05,
                                  tb_each_oc_sep_0_05_Total_of_BH_0.05,
                                  tb_each_oc_sep_0_05_Total_of_Gilbert)

alpha <- 0.04
tb_each_oc_sep_0_04 <- NULL
for (i in 1:43)
  {
  OC_inds  <- 1:473 + 473*(i-1)
  tb <- main_proc(p = p[OC_inds],
                  alpha_star = alpha_star[OC_inds],
                  f_n = f_n[OC_inds],
                  kappa = kappa[OC_inds],
                  alpha = alpha,lambda = lambda)
  tb_each_oc_sep_0_04 <- rbind(tb_each_oc_sep_0_04,tb)
  }

tb_each_oc_sep_0_04_Total_of_BH_0.04 <- c(NA,NA,colSums(tb_each_oc_sep_0_04[2*(1:43)-1,3:6],na.rm = T))
tb_each_oc_sep_0_04_Total_of_Gilbert <- c(NA,NA,colSums(tb_each_oc_sep_0_04[2*(1:43)  ,3:6],na.rm = T))
tb_each_oc_sep_0_04_with_totals <- rbind(tb_each_oc_sep_0_04,
                                  tb_each_oc_sep_0_04_Total_of_BH_0.04,
                                  tb_each_oc_sep_0_04_Total_of_Gilbert)

save(tb_each_oc_sep_0_05_with_totals,tb_each_oc_sep_0_04_with_totals,file="tables_each.RData")

```

```{r print_tables, include = T, eval = T, results='asis'}
rm(list = ls())
load("tables_all.RData")
load("tables_each.RData")
## 46 variables of interest:
XrayVariableList <- c("Number.Of.Thoracic.Vertebrae","Number.Of.Lumbar.Vertebrae","Number.Of.Pelvic.Vertebrae","Number.Of.Caudal.Vertebrae", "Transitional.Vertebrae" , "Shape.Of.Vertebrae","Fusion.Of.Vertebrae", "Processes.On.Vertebrae","Maxilla","Zygomatic.Bone","Number.Of.Cervical.Vertebrae","Skull.Shape","Number.Of.Ribs.Right","Number.Of.Ribs.Left","Shape.Of.Ribcage","Shape.Of.Ribs","Rib.Fusions","Clavicle","Scapula"  ,"Humerus","Radius","Ulna","Pelvis","Femur","Tibia","Fibula","Joints","Shape.Of.Spine","Teeth","Mandible","Number.Of.Digits","Digit.Integrity","Syndactylism","Polysyndactylism","Brachydactylism","Kyphosis","Lordosis","Scoliosis","Spinous.Processes","Transverse.Processes","Fusion.Processes","Caudal.Processes","Cervical.Processes","Lumbar.Processes","Sacral.Processes","Thoracic.Processes")    

## remove 3 variables with no values:
XrayVariableList_c <- XrayVariableList[!(XrayVariableList %in% c("Spinous.Processes","Transverse.Processes","Processes.On.Vertebrae"))]

#-------------  10 first 2x2 tables: -----------------
# pa_BH              <- p.adjust(p,"BH")
# ind <- which(pa_BH<=0.05)
# o <- order(pa_BH[ind])
# j <- 1
# for (i in ind[o][1:10])
#   {
#   print(kable(ptable(i %% 473,1+ (i %/% 473))))
#   }
# 
#-------------  Rejections in each procedure : -----------------

# table 1:
colnames(tb_all) <- c("size","pi_0","Original_pv",".","Mid_pv","..")
rownames(tb_all) <- c("BH","BH 0.05","Gilbert")

# table 2:
colnames(tb_rej_in_each_oc_0_05) <- c("Original_pv",".","Mid_pv","..")
rownames(tb_rej_in_each_oc_0_05) <- XrayVariableList_c

# table 3:
colnames(tb_rej_in_each_oc_Gilb) <- c("Original_pv",".","Mid_pv","..")
rownames(tb_rej_in_each_oc_Gilb) <- XrayVariableList_c

# table 4:
oc_names <- c(as.vector(rbind(XrayVariableList_c,NA)),"Total",NA)
colnames(tb_each_oc_sep_0_05_with_totals) <- c("size","pi_0","Original_pv",".","Mid_pv","..")
rownames(tb_each_oc_sep_0_05_with_totals) <- NULL 
tb_each_oc_sep_0_05_1 <- data.frame(oc_names,Family=rep(c("BH_0.05","Gilbert"),44),tb_each_oc_sep_0_05_with_totals)

# table 5:
colnames(tb_each_oc_sep_0_04_with_totals) <- c("size","pi_0","Original_pv",".","Mid_pv","..")
rownames(tb_each_oc_sep_0_04_with_totals) <- NULL 
tb_each_oc_sep_0_04_1 <- data.frame(oc_names,Family=rep(c("BH_0.05","Gilbert"),44),tb_each_oc_sep_0_04_with_totals)

kable(data.frame(tb_all),digits=4,caption="table 1:...",format="latex")
kable(data.frame(tb_rej_in_each_oc_0_05),caption="table 2:...",format="latex")
kable(data.frame(tb_rej_in_each_oc_Gilb),caption="table 3:...",format="latex")
kable(tb_each_oc_sep_0_05_1, digits=4,caption="table 4:...",format="latex")
kable(tb_each_oc_sep_0_04_1, digits=4,caption="table 5:...",format="latex")

```

