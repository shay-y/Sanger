---
title: "Sanger Rare Event Data Analysis."
author: "S.Y"
date: "Tuesday, January 12, 2015"
output: pdf_document 
---

```{r, read_data,echo=FALSE,include=FALSE}
rm(list = ls())
## read 0\1 data:
ZO_data <- read.csv(file = "Oct29_2014_Xray_B6N_MGPSelect_Oor1_cleaned.csv") # 8176,79 

## 46 variables of interest:
XrayVariableList <- c("Number.Of.Thoracic.Vertebrae","Number.Of.Lumbar.Vertebrae","Number.Of.Pelvic.Vertebrae","Number.Of.Caudal.Vertebrae", "Transitional.Vertebrae" , "Shape.Of.Vertebrae","Fusion.Of.Vertebrae", "Processes.On.Vertebrae","Maxilla","Zygomatic.Bone","Number.Of.Cervical.Vertebrae","Skull.Shape","Number.Of.Ribs.Right","Number.Of.Ribs.Left","Shape.Of.Ribcage","Shape.Of.Ribs","Rib.Fusions","Clavicle","Scapula"  ,"Humerus","Radius","Ulna","Pelvis","Femur","Tibia","Fibula","Joints","Shape.Of.Spine","Teeth","Mandible","Number.Of.Digits","Digit.Integrity","Syndactylism","Polysyndactylism","Brachydactylism","Kyphosis","Lordosis","Scoliosis","Spinous.Processes","Transverse.Processes","Fusion.Processes","Caudal.Processes","Cervical.Processes","Lumbar.Processes","Sacral.Processes","Thoracic.Processes")    

## remove 3 variables with no values:
XrayVariableList_c <- XrayVariableList[!(XrayVariableList %in% c("Spinous.Processes","Transverse.Processes","Processes.On.Vertebrae"))]

## remove 3 cases with all NA's and leave in variables of interest only:
ZO_data1 <- ZO_data[-which(apply(ZO_data[XrayVariableList_c],1,function(x) all(is.na(x))))
,c("Colony.Prefix","Genotype2","Genotype",XrayVariableList_c)]

# count the number of mices in each KO group (except WT group)
n_t     <- aggregate(. ~ Genotype2 + Colony.Prefix, data = ZO_data1, subset = Genotype2 !="WT",
                     function(x) sum(!is.na(x)),na.action=NULL)
# count the number NAs in each KO group (except WT group)
na_KO <- aggregate(. ~ Genotype2 + Colony.Prefix, data = ZO_data1, subset = Genotype2 !="WT",
                     function(x) sum(is.na(x)),na.action=NULL)

# count the number of mices-marked-with-one in each KO group (except WT group)
n <- aggregate(. ~ Genotype2 + Colony.Prefix,data = ZO_data1,subset = Genotype2 !="WT",
               sum, na.action=NULL, na.rm=T)

# count the number of mices in the WT group
N_minus_n_t <- aggregate(. ~ Genotype2 ,data = ZO_data1,subset = Genotype2 =="WT",
                         function(x) sum(!is.na(x)),na.action=NULL)

# count the number NAs in the WT group
na_WT <- aggregate(. ~ Genotype2 ,data = ZO_data1,subset = Genotype2 =="WT",
                         function(x) sum(is.na(x)),na.action=NULL)

# count the number of mices-marked-with-one in the WT
n_u_minus_n <- aggregate(. ~ Genotype2 ,data = ZO_data1,subset = Genotype2 =="WT",
                         sum, na.action=NULL, na.rm=T)

### Objects dimensions and descriptions:

## n           : 473 X 46 - number of faulted mice in each of the 473 KO (rows) in each outcome (columns)
## n_t         : 473 X 46 - number of tested  mice in each of the 473 KO (rows) in each outcome (columns)
## n_u_minus_n : 1 X 46   - number of faulted WT in each outcome (columns)
## N_minus_n_t : 1 X 46   - number of tested  WT in each outcome (columns)

## na_KO       : 473 X 46 - number of NAs in each KO and outcome
## na_WT       : 1 X 46   - number of NAs in WT for each outcome

### For one outcome (column i)

## n[,i]           : 473 values - number of faulted mice in each of the 473 KO((x = #white balls drawn))
## n_t[,i]         : 473 values - number of tested  mice in each of the 473 KO((k = #balls drawn))
## n_u_minus_n[,i] : one value  - number of faulted WT 
## N_minus_n_t[,i] : one value  - number of tested  WT = 1853

### more notations:

## n_u - faulted mice in total ((m = white balls))
## B   - last value in the support of HG distribution, is min{n_t,n_u} - the minimum between total faults in both groups and tested mice in KO group
```

```{r print_2x2_tables, include=FALSE} 
## print 2X2 table for outcome i and KO j:
ptable <- function(j,i)
{
  n_u1 <- n_u_minus_n[,i]+n[j,i]
  N1 <- N_minus_n_t[,i] + n_t[j,i]
  n_t1 <- n_t[j,i]
  n1  <- pmin(n[j,i],n_t1,n_u1)
  tb <- matrix(c(n1     ,n_u1-n1       ,  n_u1,
               n_t1-n1,N1-n_t1-n_u1+n1,N1-n_u1,
               n_t1   ,N1-n_t1        ,N1),
               nrow=3,ncol=3,byrow=T)
  dimnames(tb) <- list("Defected"=c("Y","N","TOTAL"),
                       "Group"=c("KO","WT","TOTAL"))
  tbna <- matrix(c(na_KO[j,i],na_WT[,i],na_KO[j,i]+na_WT[,i]),nrow=1,ncol=3,byrow=T)
  dimnames(tbna) <- list("#NAs","Group"=c("KO","WT","TOTAL"))
  print(tb)
  print(tbna)
}

ptable(4,4)
ptable(8,8)
ptable(10,10)
```

```{r aggregate_over_all_outcomes,echo=FALSE}
## reshape data for analysis of all KO together
vec_n_t         <- as.vector(as.matrix(n_t[-(1:3)]))
vec_na_KO       <- as.vector(as.matrix(na_KO[-(1:3)]))
vec_n           <- as.vector(as.matrix(n[-(1:3)]))
vec_N_minus_n_t <- rep(as.vector(as.matrix(N_minus_n_t[-(1:3)])),each=nrow(n))
vec_na_WT       <- rep(as.vector(as.matrix(na_WT[-(1:3)])),each=nrow(n))
vec_n_u_minus_n <- rep(as.vector(as.matrix(n_u_minus_n[-(1:3)])),each=nrow(n))

# ## reference:
# a=matrix(1:15,ncol=3)
# 
# dimnames(a) <- list("KO"=1:5,"OUTCOMES"=1:3)
# a
# (va <- as.vector(a))
# 
# b=matrix(c(1,6,11),ncol=3)
# b
# (vb <- as.vector(b))
# 
# rbind(va,vb) # not desired result
# 
# repb <- rep(vb, each=nrow(a)) # use 'each' argument
# 
# rbind(va,repb) # OK

```

```{r, include=FALSE}
## function to calculate the size of the Tarone family,
## finds K(alpha)=inf{1:j|m(alpha,j)<=j} where m(alpha,j)=#{i|alpha_star[i]<=alpha/j}
findK <- function(alpha_star,alpha=0.05,verbose=T)
{
  la    <- length(alpha_star) 
  m     <- vector(length=la)
  for (j in 1:la)    m[j] <- sum(alpha_star<=(alpha/j))
  K <- (1:la)[which(m<=(1:la))[1]]
  if (is.na(K)) stop("something is wrong, check alpha_star for NAs and findK() definition")
  if (verbose) cat("K = ",K,"\n")
  return (K)
}

Pi_0_est_EU <- function(p,f_n,kappa,in_fam,lambda)
{
  ## sixe of the sub-family:
  m_tag <- sum(in_fam)
  ## logical vector of size of in_fam that indicates where p-value is between lambda and lambda + next step in pdf:
  lpl <- (lambda < p[in_fam]) & (p[in_fam] <= lambda + kappa[in_fam]*f_n[in_fam])
  ## formula for the conditional expectation over uniform (0,1):
  ecdf_lambda_EU <- (sum(p[in_fam]<=lambda))/m_tag + (sum(1 - (p[in_fam][lpl]-lambda) / (kappa[in_fam][lpl]*f_n[in_fam][lpl]) ))/m_tag
  ## and the expectation of the pi_0 estimate
  Pi_0_hat_EU <- (1-ecdf_lambda_EU)/(1-lambda)
  return(Pi_0_hat_EU)
}

## work with phyper() notation:
mm <- vec_n_u_minus_n + vec_n
nn <- vec_N_minus_n_t + vec_n_t - mm
kk  <- vec_n_t
BB  <- pmin(mm,kk)
stopifnot(vec_n<=BB)
xx  <- pmin(vec_n,BB)

## get pv (right tail) and alpha star:
p  <- dhyper(x = xx, m = mm, n = nn, k = kk) + phyper(q = xx, m = mm, n = nn, k = kk, lower.tail = FALSE)
alpha_star <- dhyper(x=BB, m = mm, n = nn, k = kk)

## get highest pdf value within the pv region:
f_n <- dhyper(x = xx, m = mm, n = nn, k = kk)
## get number of occurences of this highest value (usually one):
kappa <- apply(cbind(BB,mm,nn,kk,f_n),1,
             function(x) sum(dhyper(x = 0:x[1], m = x[2], n = x[3], k = x[4])==x[5]))
set.seed(100)
u <- runif(n=length(f_n))
p_rand <- p-u*kappa*f_n

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ---------- Adjustment 1 -------------------

## BH adjustment:
pa_BH              <- p.adjust(p,"BH")

## BH on "minimum attainable pv" ( alpha_star) smaller than 0.05:
F_0.05             <- alpha_star<=0.05
size_F_0.05        <- sum(F_0.05)
pa_BH_0.05         <- rep(1,length(F_0.05))
pa_BH_0.05[F_0.05] <- p.adjust(p[F_0.05],"BH")

## BH on Tarone family:
K               <- 16938 #findK(alpha_star)
F_Gilb          <- alpha_star<=0.05/K
pa_Gilb         <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p.adjust(p[F_Gilb],"BH")

## estimation of m1 for each sub-family thresholded by alpha_star
lambda <- 0.05
t <- sort(alpha_star)
#   for (j in 1:length(t))
#   {
#     in_fam <- alpha_star <= t[j]
#     Pi_0_hat_EU <- Pi_0_est_EU(p = p,f_n = f_n,kappa = kappa,in_fam = in_fam,lambda = lambda)
#     m1_hat[j]  <- sum(in_fam)*(1-Pi_0_hat_EU)
#     if (!(j%%100)) cat(j,"\n")
#   }
#   save(m1_hat,file = "m1_hat.RData")
load(file = "m1_hat.RData")

# choice of optimum sub family:
argmax_m1_hat <-  20000 #which.max(m1_hat)

F_new <- alpha_star <= t[argmax_m1_hat]
size_F_new <- sum(F_new)
pa_new <- rep(1,length(F_new))
pa_new[F_new] <- p.adjust(p[F_new],"BH")

# summaries rejections: 
c1 <- c(sum(pa_BH<=0.05),sum(pa_BH_0.05<=0.05),sum(pa_Gilb<=0.05),NA)

# ----- functions for adpative procedure: ------------------------------

pi_0_est_rand <- function(p_rand, in_fam, lambda)
  sum(lambda<p_rand[in_fam])/(1-lambda)/sum(in_fam)

p_adjust_adaptive <- function(p,pi_0_hat)
{
  lp <- length(p)
  i <- lp:1L
  o <- order(p, decreasing = TRUE)
  ro <- order(o)
  pmin(1, cummin(lp*pi_0_hat/i * p[o]))[ro]
}

# ---------- Adjustment 2 : adaptive (m0 estimation) lambda 0.05-------------------
lambda <- 0.05

## BH adjustment:
pi_0_all  <-  pi_0_est_rand(p_rand = p_rand, in_fam = rep(T,length(p_rand)),lambda = lambda)
pa_BH              <- p_adjust_adaptive(p = p, pi_0_hat = pi_0_all)

## BH on "minimum attainable pv" ( alpha_star) smaller than 0.05:
F_0.05             <- alpha_star<=0.05
size_F_0.05        <- sum(F_0.05)
pi_0_0.05      <- pi_0_est_rand(p_rand = p_rand, in_fam = F_0.05,lambda = lambda)
pa_BH_0.05         <- rep(1,length(F_0.05))
pa_BH_0.05[F_0.05] <- p_adjust_adaptive(p = p[F_0.05], pi_0_hat = pi_0_0.05)

## BH on Tarone family:
K               <- 16938 #findK(alpha_star)
F_Gilb          <- alpha_star<=0.05/K
pi_0_Tar   <- pi_0_est_rand(p_rand = p_rand, in_fam = F_Gilb,lambda = lambda)
pa_Gilb         <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p_adjust_adaptive(p = p[F_Gilb], pi_0_hat = pi_0_Tar)

## estimation of m1 for each sub-family thresholded by alpha_star
# t <- sort(alpha_star)
#   for (j in 1:length(t))
#   {
#     in_fam <- alpha_star <= t[j]
#     Pi_0_hat_EU <- Pi_0_est_EU(p = p,f_n = f_n,kappa = kappa,in_fam = in_fam,lambda = lambda)
#     m1_hat[j]  <- sum(in_fam)*(1-Pi_0_hat_EU)
#     if (!(j%%100)) cat(j,"\n")
#   }
#   save(m1_hat,file = "m1_hat.RData")
#load(file = "m1_hat.RData")

# choice of optimum sub family:
#argmax_m1_hat <-  20000 #which.max(m1_hat)

# F_new <- alpha_star <= t[argmax_m1_hat]
# size_F_new <- sum(F_new)
# pa_new <- rep(1,length(F_new))
# pa_new[F_new] <- p.adjust(p[F_new],"BH")

# summaries rejections: 
c2 <- c(sum(pa_BH<=0.05),sum(pa_BH_0.05<=0.05),sum(pa_Gilb<=0.05),NA)
pi0_0.05 <- c(pi_0_all,pi_0_0.05,pi_0_Tar)
# [1] 1.001659 1.000942 1.005090

# ---------- Adjustment 3 : adaptive (m0 estimation) lambda 0.5-------------------
lambda <- 0.5

## BH adjustment:
pi_0_all           <-  pi_0_est_rand(p_rand = p_rand, in_fam = rep(T,length(p_rand)),lambda = lambda)
pa_BH              <- p_adjust_adaptive(p = p, pi_0_hat = pi_0_all)

## BH on "minimum attainable pv" ( alpha_star) smaller than 0.05:
F_0.05             <- alpha_star<=0.05
size_F_0.05        <- sum(F_0.05)
pi_0_0.05          <- pi_0_est_rand(p_rand = p_rand, in_fam = F_0.05,lambda = lambda)
pa_BH_0.05         <- rep(1,length(F_0.05))
pa_BH_0.05[F_0.05] <- p_adjust_adaptive(p = p[F_0.05], pi_0_hat = pi_0_0.05)

## BH on Tarone family:
K               <- 16938 #findK(alpha_star)
F_Gilb          <- alpha_star<=0.05/K
pi_0_Tar        <- pi_0_est_rand(p_rand = p_rand, in_fam = F_Gilb,lambda = lambda)
pa_Gilb         <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p_adjust_adaptive(p = p[F_Gilb], pi_0_hat = pi_0_Tar)

## estimation of m1 for each sub-family thresholded by alpha_star
# t <- sort(alpha_star)
#   for (j in 1:length(t))
#   {
#     in_fam <- alpha_star <= t[j]
#     Pi_0_hat_EU <- Pi_0_est_EU(p = p,f_n = f_n,kappa = kappa,in_fam = in_fam,lambda = lambda)
#     m1_hat[j]  <- sum(in_fam)*(1-Pi_0_hat_EU)
#     if (!(j%%100)) cat(j,"\n")
#   }
#   save(m1_hat,file = "m1_hat.RData")
#load(file = "m1_hat.RData")

# choice of optimum sub family:
#argmax_m1_hat <-  20000 #which.max(m1_hat)

# F_new <- alpha_star <= t[argmax_m1_hat]
# size_F_new <- sum(F_new)
# pa_new <- rep(1,length(F_new))
# pa_new[F_new] <- p.adjust(p[F_new],"BH")

# summaries rejections: 
c3 <- c(sum(pa_BH<=0.05),sum(pa_BH_0.05<=0.05),sum(pa_Gilb<=0.05),NA)
pi0_0.5 <- c(pi_0_all,pi_0_0.05,pi_0_Tar)
# [1] 1.062746 1.070144 1.098713

# ---------- Adjustment 4 mid pv -------------------
p_mid <- p - f_n*0.5

## BH adjustment:
pa_BH              <- p.adjust(p_mid,"BH")

## BH on "minimum attainable pv" ( alpha_star) smaller than 0.05:
F_0.05             <- alpha_star<=0.05
size_F_0.05        <- sum(F_0.05)
pa_BH_0.05         <- rep(1,length(F_0.05))
pa_BH_0.05[F_0.05] <- p.adjust(p_mid[F_0.05],"BH")

## BH on Tarone family:
K               <- 16938
F_Gilb          <- alpha_star<=0.05/K
pa_Gilb         <- rep(1,length(F_Gilb))
pa_Gilb[F_Gilb] <- p.adjust(p_mid[F_Gilb],"BH")

## estimation of m1 for each sub-family thresholded by alpha_star
#lambda <- 0.05
#t <- sort(alpha_star)
#   for (j in 1:length(t))
#   {
#     in_fam <- alpha_star <= t[j]
#     Pi_0_hat_EU <- Pi_0_est_EU(p = p_mid,f_n = f_n,kappa = kappa,in_fam = in_fam,lambda = lambda)
#     m1_hat[j]  <- sum(in_fam)*(1-Pi_0_hat_EU)
#     if (!(j%%100)) cat(j,"\n")
#   }
#   save(m1_hat,file = "m1_hat.RData")
#load(file = "m1_hat.RData")

# choice of optimum sub family:
argmax_m1_hat <-  20000 #which.max(m1_hat)

F_new <- alpha_star <= t[argmax_m1_hat]
size_F_new <- sum(F_new)
pa_new <- rep(1,length(F_new))
pa_new[F_new] <- p.adjust(p_mid[F_new],"BH")

# summaries rejections: 
c4 <- c(sum(pa_BH<=0.05),sum(pa_BH_0.05<=0.05),sum(pa_Gilb<=0.05),NA)

# ---------- Adjustment 5 realized randomized -------------------

## BH on "minimum attainable pv" ( alpha_star) smaller than 0.05:
F_0.05             <- alpha_star<=0.05
size_F_0.05        <- sum(F_0.05)

## BH on Tarone family:
K               <- 16938
F_Gilb          <- alpha_star<=0.05/K

## estimation of m1 for each sub-family thresholded by alpha_star
lambda <- 0.05
t <- sort(alpha_star)
#   for (j in 1:length(t))
#   {
#     in_fam <- alpha_star <= t[j]
#     Pi_0_hat_EU <- Pi_0_est_EU(p = p_rand,f_n = f_n,kappa = kappa,in_fam = in_fam,lambda = lambda)
#     m1_hat[j]  <- sum(in_fam)*(1-Pi_0_hat_EU)
#     if (!(j%%100)) cat(j,"\n")
#   }
#   save(m1_hat,file = "m1_hat.RData")
#load(file = "m1_hat.RData")

# choice of optimum sub family:
argmax_m1_hat <-  20000 #which.max(m1_hat)
F_new <- alpha_star <= t[argmax_m1_hat]
size_F_new <- sum(F_new)

# B <- 1000
# out <- matrix(0,nrow=length(p),ncol=3)
# 
# for (i in 1:B)
#   {
# set.seed(i)
# u <- runif(n=length(f_n))
# p_rand <- p-u*kappa*f_n
# pa_BH              <- p.adjust(p_rand,"BH")
# pa_BH_0.05         <- rep(1,length(F_0.05))
# pa_BH_0.05[F_0.05] <- p.adjust(p_rand[F_0.05],"BH")
# pa_Gilb         <- rep(1,length(F_Gilb))
# pa_Gilb[F_Gilb] <- p.adjust(p_rand[F_Gilb],"BH")
# out <- out + cbind(pa_BH<=0.05,pa_BH_0.05<=0.05,pa_Gilb<=0.05)
# if (!(i%%100)) cat(i,"\n")
# }
# save(out,file = "rr_out.RData")

save(list = ls(all = TRUE), file= "all.RData")
# xxx <- rhyper(nn = length(xx), m = mm, n = nn, k = kk)


```


```{r}
load("all.RData")
load(file = "rr_out.RData")
ptable <- function(j,i)
{
  n_u1 <- n_u_minus_n[,i]+n[j,i]
  N1 <- N_minus_n_t[,i] + n_t[j,i]
  n_t1 <- n_t[j,i]
  n1  <- pmin(n[j,i],n_t1,n_u1)
  tb <- matrix(c(n1     ,n_u1-n1       ,  n_u1,
               n_t1-n1,N1-n_t1-n_u1+n1,N1-n_u1,
               n_t1   ,N1-n_t1        ,N1),
               nrow=3,ncol=3,byrow=T)
  dimnames(tb) <- list("Defected"=c("Y","N","TOTAL"),
                       "Group"=c("KO","WT","TOTAL"))
  tbna <- matrix(c(na_KO[j,i],na_WT[,i],na_KO[j,i]+na_WT[,i]),nrow=1,ncol=3,byrow=T)
  dimnames(tbna) <- list("#NAs","Group"=c("KO","WT","TOTAL"))
  print(t(tb))
  #print(tbna)
}

# 1. 35 first 2x2 tables:
pa_BH              <- p.adjust(p,"BH")
ind <- which(pa_BH<=0.05)
o <- order(pa_BH[ind])
j <- 1
for (i in ind[o])
  {
  cat(j,":  pv = ",pa_BH[i],"\n")
  ptable(i %% 669,3 + i %/% 669)
  cat("\n")
  j <- j+1
  }

#2. summary of rejections in each procedure :
r <- cbind(c1,c2,c3,c4)
colnames(r) <- c("simple pv","adaptive 0.05","adaptive 0.5","mid pv")
rownames(r) <- c("BH","BH_0.05","Gilbert"," ")
r[-4,]

rr <- cbind(pi0_0.05,pi0_0.5)
colnames(rr) <- c("l 0.05","l 0.5")
rownames(rr) <- c("BH","BH_0.05","Gilbert")
rr

#4, realized rendomized results:
sum((out[,1]/1000)==1)
sum((out[,1]/1000)>0.75)
sum((out[,1]/1000)>0.5)
sum((out[,1]/1000)>0.25)
```

```{r, fig.height=4,fig.width=4}
#3. plots:
plot(sort(alpha_star),type="l",main="alpha star")
plot(m1_hat,type="l",main="m1 estimates")
plot(sort(p),type="l",main="sorted p values")
plot(sort(p_mid),type="l",main="sorted mid p values")

```


```{r ,include=FALSE}


## function to calculate the size of the Tarone family:
findK <- function(alpha_star,alpha=0.05,range = NULL,verbose=T)
  # finds K(alpha)=inf{1:j|m(alpha,j)<=j} where m(alpha,j)=#{i|alpha_star[i]<=alpha/j}
{
  la <- length(alpha_star) 
  if (is.null(range))
    range <- 1:la
  m <- vector(length=la)
  for (j in range)
  {
    m[j] <- sum(alpha_star<=(alpha/j))
    #cat("j: ",j," m[j]:",m[j],"\n")
  }
  K <- (1:la)[which(m<=(1:la))[1]]
  if (verbose) cat("K = ",K,"\n")
  return (K)
}

lambda <- 0.05

alpha_star<-p<-p_rand<-pa_BH<-pa_BH_0.05<-pa_Gilb<-pa_new<-m1_hat<- matrix(NA,nrow = nrow(n), ncol = ncol(n))
size_F_0.05 <- K <- argmax_m1_hat<-  rep(NA,ncol(n))

for (i in 4:46)
{i=4
  # work with phyper() notation:
  mm <- n_u_minus_n[,i]+n[,i]
  nn <- N_minus_n_t[,i] + n_t[,i] - mm
  kk  <- n_t[,i]
  BB  <- pmin(mm,kk)
  stopifnot(n[,i]<=BB)
  xx  <- pmin(n[,i],BB)
  
  # get pv (right tail) and alpha star:
  p[,i]  <- dhyper(x = xx, m = mm, n = nn, k = kk) + phyper(q = xx, m = mm, n = nn, k = kk, lower.tail = FALSE)
  alpha_star[,i] <- dhyper(x=BB, m = mm, n = nn, k = kk)

  f_n <- dhyper(x = xx, m = mm, n = nn, k = kk)
  kappa <- apply(cbind(BB,mm,nn,kk,f_n),1,
               function(x) sum(dhyper(x = 0:x[1], m = x[2], n = x[3], k = x[4])==x[5]))

  # BH adjustment:
  pa_BH[,i] <- p.adjust(p[,i],"BH")
  
  # BH on minimum attainble pv smaller than sig. level 0.05:
  F_0.05 <- alpha_star[,i]<=0.05
  size_F_0.05[i] <- sum(F_0.05)
  pa_BH_0.05[,i] <- 1
  pa_BH_0.05[F_0.05,i] <- p.adjust(p[F_0.05,i],"BH")
  
  # BH on Tarone family:
  K[i] <- findK(alpha_star[,i])
  F_Gilb <- alpha_star[,i]<=0.05/K[i]
  pa_Gilb[,i] <- 1
  pa_Gilb[F_Gilb,i] <- p.adjust(p[F_Gilb,i],"BH")
  
  # estimation of m1 for each sub-family thresholded by alphastar
  t <- sort(alpha_star[,i])
  for (j in 1:length(t))
    {j=200
    in_fam <- alpha_star[,i] <= t[j]
    m_tag <- sum(in_fam)
    
    lpl <- (lambda < p[in_fam,i]) & (p[in_fam,i] <= lambda + kappa[in_fam]*f_n[in_fam])
    EU_ecdf_lambda <- (sum(p[in_fam,i]<=lambda))/m_tag + (sum(1 - (p[lpl,i]-lambda) / (kappa[lpl]*f_n[lpl]) ))/m_tag
           
    EU_Pi_0_hat <- (1-EU_ecdf_lambda)/(1-lambda)
    
    m1_hat[,i]  <- m_tag*(1-EU_Pi_0_hat)
    }
  # choice of optimum sub family:
  argmax_m1_hat[i] <- which.max(m1_hat[,i])
  
  F_new <- alpha_star[,i]<=t[argmax_m1_hat[i]]
  pa_new[,i] <- 1
  pa_new[F_new,i] <- p.adjust(p[F_new,i],"BH")
}
m1_hat


Rej <- data.frame(size_F_0.05,K,argmax_m1_hat,BH=apply(pa_BH,2,function(x) sum(x<=0.05)),BH0.05=apply(pa_BH_0.05,2,function(x) sum(x<=0.05)),Gilbert=apply(pa_Gilb,2,function(x) sum(x<=0.05)),m1est=apply(pa_new,2,function(x) sum(x<=0.05)))[-(1:3),]

Rejdiff <- data.frame("BH0.05--BH"=Rej[3+2]-Rej[3+1],"Gilb--BH"=Rej[3+3]-Rej[3+1],"m1est--BH"=Rej[3+4]-Rej[3+1])
rownames(Rej) <- XrayVariableList_c
rownames(Rejdiff) <- XrayVariableList_c

Rej
colSums(Rej)
Rejdiff
colSums(Rejdiff)  
```
```{r echo=FALSE,include=FALSE}
#   # kk<=mm
#   mm <- 7
#   nn <- 10
#   kk <- 6
#   B <- min(kk,mm)
#   xx <- 4:B
#   
#   dhyper(x=xx, m = mm, n = nn, k = kk)
#   choose(mm,xx)*choose(nn,kk-xx)/choose(mm+nn,kk)
#   choose(mm,kk)/choose(mm+nn,kk)
#   
#   # kk>mm
#   mm <- 7
#   nn <- 10
#   kk <- 8
#   B <- min(kk,mm)
#   xx <- 4:B
#   
#   dhyper(x=xx, m = mm, n = nn, k = kk)
#   choose(mm,xx)*choose(nn,kk-xx)/choose(mm+nn,kk)
#   choose(nn,kk-mm)/choose(mm+nn,kk)

```
```{r,fig.height=16,fig.width=7,echo=FALSE,include=FALSE}
#  plots:
par(mfrow=c(2,3))
for (i in 3+(1:43))
{
  plot(sort(p[,i]),type="l",main = "p-value")
  plot(sort(alpha_star[,i]),type="l",main = "alpha_star")
#   asf <- table(alpha_star[,i])
#   asv <- as.numeric(names(asf))
#   plot(asv,cumsum(asf),type="h",lwd=1,col="darkgrey",xlab="x",ylab="counts")
  plot(m1_hat[,i],type="l",main = "m1 hat ")
  abline(v=c(size_F_0.05[i],K[i],argmax_m1_hat[i]),col=c("brown","red","orange"))
}
```

